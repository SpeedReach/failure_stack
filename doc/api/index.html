<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="generator" content="made with love by dartdoc 6.2.2">
  <meta name="description" content="failure_stack API docs, for the Dart programming language.">
  <title>failure_stack - Dart API docs</title>


  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" rel="stylesheet">
  
  <link rel="stylesheet" href="static-assets/github.css?v1">
  <link rel="stylesheet" href="static-assets/styles.css?v1">
  <link rel="icon" href="static-assets/favicon.png?v1">

  
</head>


<body data-base-href="" data-using-base-href="false" class="light-theme">

<div id="overlay-under-drawer"></div>

<header id="title">
  <span id="sidenav-left-toggle" class="material-symbols-outlined" role="button" tabindex="0">menu</span>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li class="self-crumb">failure_stack package</li>
  </ol>
  <div class="self-name">failure_stack</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
  <div class="toggle" id="theme-button">
    <label for="theme">
      <input type="checkbox" id="theme" value="light-theme">
      <span id="dark-theme-button" class="material-symbols-outlined">
        brightness_4
      </span>
      <span id="light-theme-button" class="material-symbols-outlined">
        brightness_5
      </span>
    </label>
  </div>
</header>
<main>

  <div id="dartdoc-main-content" class="main-content">
      
<section class="desc markdown">
  <p></p>
<p align="center">
<a href=""><img src="https://github.com/SpeedReach/failure_stack/actions/workflows/build.yml/badge.svg" alt="build"></a>
<a href=""><img src="https://codecov.io/gh/SpeedReach/failure_stack/blob/main/graph/badge.svg" alt="codecov"></a>
</p>
<hr>
<p>A error handling library inspired by rust and error-stack.</p>
<h2 id="why-use-failure_stack-">Why use failure_stack ?</h2>
<p>The origin error handle method: throw catch, may cause unpredicted errors and behaviors,
by using the result type as the return value. You are forced to handle every failure that might
occur, making your program less likely to cause errors.<br>
You may say, I get it , Result and Either types are great, but dartz and fpdart already that
has these, why create another library?  The above mentioned are great libraries for dart functional programming,
but when it comes to error handling , they might not be ideal when your program becomes larger and contains a lot nested function calls.
So above the normal Either type, this package has some additional features.</p>
<ol>
<li>encourage the user to provide a new error type if the scope is changed, usually by crossing layers in apps or 3rd party libraries(for example, <code>ApiError</code> for infrastructure layer errors and <code>InvalidInputError</code> for application layers.)</li>
<li>be able to attach any extra data to failures</li>
<li>be able to push failures to the stack and handle them later while still keeping track of them.</li>
</ol>
<p>
  <img src="https://github.com/SpeedReach/failure_stack/blob/main/doc/example-1.jpeg?raw=true" alt="An image of the failure stack" height="300">
</p>
<h2 id="usage">Usage</h2>
<p>Let's say we have a function that parses a <code>String</code> to <code>int</code>, and it may fail when the input is not a number.</p>
<pre class="language-dart"><code class="language-dart">class ParsingFailure{} // The failure representing that the parsing failed

Result&lt;int,ParsingFailure&gt; parse(String numString);

</code></pre>
<p>When we use the function, we have 3 ways to handle the result.</p>
<ol>
<li>When you don't care about the failure that might occur.</li>
</ol>
<pre class="language-dart"><code class="language-dart">// .ok returns the contained ok value, since the result might fail, it is a nullable type.
int? result = parse(targetString).ok;
</code></pre>
<ol start="2">
<li>Exhaustive matching.</li>
</ol>
<pre class="language-dart"><code class="language-dart">switch(parse(targetString)){
  case Ok&lt;int,ParsingFailure&gt; ok: {
    print("success: ${ok.value}");
  },  
  case Fail&lt;int,ParsingFailure&gt; fail: {
    print("Failed: ${fail.failure}");
  } 
}
</code></pre>
<ol start="3">
<li>When you are in a function that returns a Result type too,
use <code>resultHandleEnvironment</code> instead.</li>
</ol>
<pre class="language-dart"><code class="language-dart">Result&lt;int,ParsingExperimentError&gt; experiment(){
   return resultHandleEnvironment(() {
     Result&lt;int,ParsingError&gt; result = parse("o13");
     // We can unwrap here safely, in other cases, unwrapping a Fail will throw error.
     // note that we use pushFailure to match Failure type
     int ok = result
             .pushFailure(ParsingExperimentError())
             .attach("extra info") //attach anything you want
             .unwrap();
     return Ok(ok);
   });
}
</code></pre>
<h3 id="converting-exceptions-and-errors-to-failure">Converting Exceptions and Errors to Failure</h3>
<ol>
<li>use the <code>intoFailure</code> function</li>
</ol>
<pre class="language-dart"><code class="language-dart">Future&lt;Result&lt;(), DioException&gt;&gt; callApi() async {
 try{
  await dio.post(/*some code*/);
 }
 on DioException catch(e){
  return e.intoFailure();
 }
}
</code></pre>
<ol start="2">
<li>write an adapter function</li>
</ol>
<pre class="language-dart"><code class="language-dart">  RepositoryFailure intoRepositoryFailure(){
    switch(type){
      case DioExceptionType.connectionTimeout:
        return const ConnectionFailure();
      case DioExceptionType.badResponse:
        if(response == null || response!.statusCode == null) {
          return const UnExpectedFailure(null);
        } else if(response!.statusCode == 401) {
          return const UnAuthorizeFailure();
        } else if(response!.statusCode! &gt;= 500) {
          return const ServerFailure();
        } else if(response!.statusCode! &gt;= 400) {
          return IllegalActionFailure(response!.statusMessage ?? "");
        }
     case DioExceptionType.unknown:
        return const UnExpectedFailure(null);
    }
  }
</code></pre>
</section>


      <section class="summary">
          <h2>Libraries</h2>
        <dl>
          <dt id="failure_stack">
  <span class="name"><a href="failure_stack/failure_stack-library.html">failure_stack</a></span> 

</dt>
<dd>
</dd>

        </dl>
      </section>

  </div> <!-- /.main-content -->

  <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
    <header id="header-search-sidebar" class="hidden-l">
  <form class="search-sidebar" role="search">
    <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
  <li class="self-crumb">failure_stack package</li>
</ol>


    <h5 class="hidden-xs"><span class="package-name">failure_stack</span> <span class="package-kind">package</span></h5>
    <ol>
      <li class="section-title">Libraries</li>
      <li><a href="failure_stack/failure_stack-library.html">failure_stack</a></li>
</ol>

  </div>

  <div id="dartdoc-sidebar-right" class="sidebar sidebar-offcanvas-right">
  </div>

</main>

<footer>
  <span class="no-break">
    failure_stack
      1.0.0
  </span>

  
</footer>



<script src="static-assets/highlight.pack.js?v1"></script>
<script src="static-assets/docs.dart.js"></script>



</body>

</html>

